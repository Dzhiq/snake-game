<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>é«˜çº§è´ªåƒè›‡</title>

<style>
body{
    margin:0;
    background:linear-gradient(135deg,#0f2027,#203a43,#2c5364);
    font-family:Arial, sans-serif;
    color:#fff;
    display:flex;
    justify-content:center;
    align-items:center;
    height:100vh;
    overflow: hidden;
}

.game-box{
    text-align:center;
    position: relative;
    max-width: 360px;
    width: 100%;
    padding: 0 10px;
}

canvas{
    background:#000;
    border-radius:12px;
    box-shadow:0 0 20px rgba(0,0,0,0.6);
    display: block;
    margin: 10px auto;
    touch-action: none;
}

h1{margin:8px 0;}

.info{
    margin:6px 0;
    font-size: 16px;
}

button{
    padding:10px 20px;
    border:none;
    border-radius:8px;
    background:#4CAF50;
    color:#fff;
    font-size:16px;
    cursor:pointer;
    margin: 5px;
}
button:hover{background:#45a049;}

.overlay{
    position:absolute;
    inset:0;
    background:rgba(0,0,0,.7);
    display:flex;
    justify-content:center;
    align-items:center;
    flex-direction:column;
    z-index: 10;
}

.hidden{display:none;}

.author {
    margin-top: 10px;
    font-size: 14px;
    color: #cccccc;
}

.difficulty-container {
    margin: 10px 0;
}

.difficulty-btn {
    padding: 8px 16px;
    font-size: 14px;
    background-color: #6c757d;
    margin: 0 4px;
}

.difficulty-btn.active {
    background-color: #007bff;
}

.level-info {
    margin: 6px 0;
    font-size: 18px;
    color: #ffeb3b;
}

.level-goal {
    margin: 4px 0;
    font-size: 14px;
    color: #4fc3f7;
}

/* âœ… å€’è®¡æ—¶æ ·å¼ä¼˜åŒ–ï¼šæ›´å¤§ã€æ›´é†’ç›® */
.timer-display {
    font-size: 28px;
    font-weight: bold;
    color: #4CAF50; /* é»˜è®¤ç»¿è‰² */
    margin: 10px 0;
    text-shadow: 0 0 8px rgba(76, 175, 80, 0.7);
    transition: color 0.3s ease;
}

/* æœ€å5ç§’å˜çº¢ */
.timer-display.warning {
    color: #ff5252;
    text-shadow: 0 0 10px rgba(255, 82, 82, 0.8);
}
</style>
</head>

<body>

<div class="game-box">
    <h1>ğŸ è´ªåƒè›‡</h1>
    <div class="info">å¾—åˆ†ï¼š<span id="score">0</span> | æœ€é«˜åˆ†ï¼š<span id="best">0</span></div>
    
    <div id="difficultyContainer" class="difficulty-container">
        <button id="easyBtn" class="difficulty-btn active" onclick="setDifficulty('easy')">ç®€å•</button>
        <button id="normalBtn" class="difficulty-btn" onclick="setDifficulty('normal')">ä¸€èˆ¬</button>
        <button id="hardBtn" class="difficulty-btn" onclick="setDifficulty('hard')">å›°éš¾</button>
    </div>

    <canvas id="game" width="320" height="320"></canvas>
    
    <div id="levelInfo" class="level-info hidden">ç¬¬ 1 å…³</div>
    <div id="levelGoal" class="level-goal hidden">ç›®æ ‡ï¼šåƒåˆ°30ä¸ªé£Ÿç‰©</div>
    <div id="timerDisplay" class="timer-display hidden">æ—¶é—´: 30s</div>
    
    <br/>
    <p class="author">Authorï¼šä¸€å¤©å…«æ¯æ°´</p>
    
    <button id="startFreeButton" onclick="startGame()">è‡ªç”±æ¨¡å¼</button>
    <button id="startLevelButton" onclick="startLevelMode()">é—¯å…³æ¨¡å¼</button>
</div>

<div id="gameOver" class="overlay hidden">
    <h2>æ¸¸æˆç»“æŸ</h2>
    <p id="finalScore"></p>
    <button onclick="backToMenu()">è¿”å›èœå•</button>
</div>

<div id="levelComplete" class="overlay hidden">
    <h2 id="levelResultText">æ­å–œè¿‡å…³!</h2>
    <p id="nextLevelHint">å³å°†è¿›å…¥ä¸‹ä¸€å…³...</p>
    <button id="nextLevelButton" onclick="nextLevel()">ä¸‹ä¸€å…³</button>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const grid = 16;

let snake, food, dx, dy, score, gameLoopIntervalId;

let gameMode = 'menu';
let currentLevel = 0;
let timeLeft = 0;
let timerIntervalId = null;
let reversedControls = false;

let currentDifficulty = 'normal';
const difficultySettings = {
    easy: { speed: 180 },
    normal: { speed: 120 },
    hard: { speed: 70 }
};

const levels = [
    {}, // å ä½ç¬¦
    {
        initialLength: 1,
        speed: 240,
        targetLength: 20,
        timeLimit: null,
        reverseControls: false,
        goalText: "ç›®æ ‡ï¼šåƒåˆ°20ä¸ªé£Ÿç‰©"
    },
    {
        initialLength: 10,
        speed: 80,
        targetLength: null,
        timeLimit: 30,
        reverseControls: false,
        goalText: "ç›®æ ‡ï¼šåšæŒ30ç§’ä¸æ­»äº¡ï¼"
    },
    {
        initialLength: 1,
        speed: 200,
        targetLength: 6,
        timeLimit: null,
        reverseControls: true,
        goalText: "ç›®æ ‡ï¼šæ–¹å‘åè½¬ï¼åƒåˆ°5ä¸ªé£Ÿç‰©"
    }
];

// UI refs
const difficultyContainer = document.getElementById('difficultyContainer');
const levelInfo = document.getElementById('levelInfo');
const levelGoal = document.getElementById('levelGoal');
const timerDisplay = document.getElementById('timerDisplay');
const startFreeButton = document.getElementById('startFreeButton');
const startLevelButton = document.getElementById('startLevelButton');
const nextLevelButton = document.getElementById('nextLevelButton');
const levelCompleteBox = document.getElementById('levelComplete');
const levelResultText = document.getElementById('levelResultText');
const easyBtn = document.getElementById('easyBtn');
const normalBtn = document.getElementById('normalBtn');
const hardBtn = document.getElementById('hardBtn');
const scoreEl = document.getElementById("score");
const bestEl = document.getElementById("best");
const gameOverBox = document.getElementById("gameOver");
const finalScore = document.getElementById("finalScore");

let best = localStorage.getItem("snake_best") || 0;
bestEl.textContent = best;

function resetAndStartLoop(speed) {
    clearInterval(gameLoopIntervalId);
    gameLoopIntervalId = setInterval(loop, speed);
}

function init(){
    if(gameMode === 'level' && currentLevel > 0 && currentLevel < levels.length) {
        const levelConfig = levels[currentLevel];
        const length = levelConfig.initialLength;
        snake = [];
        for(let i = 0; i < length; i++) {
            snake.push({x: 10 - i, y: 10});
        }
        reversedControls = levelConfig.reverseControls;
        dx = 1;
        dy = 0;
    } else {
        snake = [{x:10,y:10}];
        reversedControls = false;
        dx = 1;
        dy = 0;
    }

    randomFood();
    score = 0;
    scoreEl.textContent = 0;
}

function randomFood(){
    let newFood;
    let onSnake;
    do {
        onSnake = false;
        newFood = {
            x: Math.floor(Math.random() * 20),
            y: Math.floor(Math.random() * 20)
        };
        for(const segment of snake) {
            if(segment.x === newFood.x && segment.y === newFood.y) {
                onSnake = true;
                break;
            }
        }
    } while (onSnake);
    food = newFood;
}

function draw(){
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "#ff5252";
    ctx.fillRect(food.x * grid, food.y * grid, grid - 2, grid - 2);

    ctx.fillStyle = "#4CAF50";
    snake.forEach((p, i) => {
        ctx.globalAlpha = 1 - i * 0.03;
        ctx.fillRect(p.x * grid, p.y * grid, grid - 2, grid - 2);
    });
    ctx.globalAlpha = 1;
}

function update(){
    const head = {x: snake[0].x + dx, y: snake[0].y + dy};

    if(
        head.x < 0 || head.y < 0 ||
        head.x >= 20 || head.y >= 20 ||
        snake.some(p => p.x === head.x && p.y === head.y)
    ){
        gameOver();
        return;
    }

    snake.unshift(head);

    if(head.x === food.x && head.y === food.y){
        score++;
        scoreEl.textContent = score;
        randomFood();
    } else {
        snake.pop();
    }

    if(gameMode === 'level') {
        const levelConfig = levels[currentLevel];
        if(levelConfig.targetLength && snake.length >= levelConfig.targetLength) {
            levelComplete();
            return;
        }
    }
}

function loop(){
    update();
    draw();
}

function changeDirection(newDx, newDy) {
    if ((newDx !== 0 && dx === 0) || (newDy !== 0 && dy === 0)) {
        if (!(dx !== 0 && newDx !== 0 && dx + newDx === 0) && !(dy !== 0 && newDy !== 0 && dy + newDy === 0)) {
            dx = newDx;
            dy = newDy;
        }
    }
}

function setDifficulty(level) {
    currentDifficulty = level;
    easyBtn.classList.toggle('active', level === 'easy');
    normalBtn.classList.toggle('active', level === 'normal');
    hardBtn.classList.toggle('active', level === 'hard');
}

function startGame(){
    gameMode = 'free';
    levelInfo.classList.add('hidden');
    levelGoal.classList.add('hidden');
    timerDisplay.classList.add('hidden');
    difficultyContainer.classList.remove('hidden');
    startFreeButton.classList.remove('hidden');
    startLevelButton.classList.remove('hidden');
    gameOverBox.classList.add("hidden");
    levelCompleteBox.classList.add("hidden");

    init();
    resetAndStartLoop(difficultySettings[currentDifficulty].speed);
}

function startLevelMode() {
    gameMode = 'level';
    currentLevel = 1;
    difficultyContainer.classList.add('hidden');
    startFreeButton.classList.add('hidden');
    startLevelButton.classList.add('hidden');
    gameOverBox.classList.add("hidden");
    levelCompleteBox.classList.add("hidden");

    startCurrentLevel();
}

// âœ… å…³é”®å‡½æ•°ï¼šå¯åŠ¨å½“å‰å…³å¡ï¼ˆå«å€’è®¡æ—¶é€»è¾‘ï¼‰
function startCurrentLevel() {
    const levelConfig = levels[currentLevel];
    levelInfo.textContent = `ç¬¬ ${currentLevel} å…³`;
    levelGoal.textContent = levelConfig.goalText;
    
    levelInfo.classList.remove('hidden');
    levelGoal.classList.remove('hidden');

    // âœ… å…ˆæ¸…é™¤å¯èƒ½æ®‹ç•™çš„å€’è®¡æ—¶
    if (timerIntervalId) {
        clearInterval(timerIntervalId);
        timerIntervalId = null;
    }

    if (levelConfig.timeLimit) {
        timeLeft = levelConfig.timeLimit;
        updateTimerDisplay();
        timerDisplay.classList.remove('hidden');
        
        // è®¾ç½®æ–°å€’è®¡æ—¶
        timerIntervalId = setInterval(() => {
            timeLeft--;
            updateTimerDisplay();
            if (timeLeft <= 0) {
                clearInterval(timerIntervalId);
                timerIntervalId = null;
                levelComplete(); // é€šå…³
            }
        }, 1000);
    } else {
        timerDisplay.classList.add('hidden');
        // æ³¨æ„ï¼šè¿™é‡Œä¸æ¸…é™¤ timerIntervalIdï¼Œå› ä¸ºä¸Šé¢å·²å¤„ç†
    }

    init(); // init ä¼šè°ƒç”¨ resetAndStartLoopï¼Œä½†ä¸ä¼šå†æ¸…å€’è®¡æ—¶äº†
    resetAndStartLoop(levelConfig.speed);
}

// âœ… æ–°å¢ï¼šç»Ÿä¸€æ›´æ–°å€’è®¡æ—¶æ˜¾ç¤ºï¼ˆå«é¢œè‰²å˜åŒ–ï¼‰
function updateTimerDisplay() {
    timerDisplay.textContent = `â³ å‰©ä½™æ—¶é—´: ${timeLeft} ç§’`;
    
    // æœ€å5ç§’å˜çº¢
    if(timeLeft <= 5) {
        timerDisplay.classList.add('warning');
    } else {
        timerDisplay.classList.remove('warning');
    }
}

function nextLevel() {
    currentLevel++;
    if(currentLevel >= levels.length) {
        levelCompleteBox.classList.add("hidden");
        gameOver("ğŸ‰ æ­å–œï¼ä½ å·²é€šå…³å…¨éƒ¨å…³å¡ï¼");
        return;
    }
    levelCompleteBox.classList.add("hidden");
    startCurrentLevel();
}

function levelComplete() {
    clearInterval(gameLoopIntervalId);
    clearInterval(timerIntervalId);
    levelResultText.textContent = "æ­å–œè¿‡å…³!";
    levelCompleteBox.classList.remove("hidden");
}

function gameOver(reason = "æ’å¢™æˆ–æ’åˆ°è‡ªå·±") {
    clearInterval(gameLoopIntervalId);
    clearInterval(timerIntervalId);
    
    if (gameMode === 'free') {
        if(score > best){
            best = score;
            localStorage.setItem("snake_best", best);
            bestEl.textContent = best;
        }
        finalScore.textContent = "æœ¬æ¬¡å¾—åˆ†ï¼š" + score;
    } else {
        finalScore.textContent = `å…³å¡ ${currentLevel} å¤±è´¥: ${reason}`;
    }
    
    gameOverBox.classList.remove("hidden");
}

function backToMenu() {
    clearInterval(gameLoopIntervalId);
    clearInterval(timerIntervalId);
    
    gameOverBox.classList.add("hidden");
    levelCompleteBox.classList.add("hidden");
    
    difficultyContainer.classList.remove('hidden');
    startFreeButton.classList.remove('hidden');
    startLevelButton.classList.remove('hidden');
    
    levelInfo.classList.add('hidden');
    levelGoal.classList.add('hidden');
    timerDisplay.classList.add('hidden');

    gameMode = 'menu';
    currentLevel = 0;
    reversedControls = false;
}

// é”®ç›˜æ§åˆ¶
document.addEventListener("keydown", e => {
    let newDx = 0, newDy = 0;
    switch(e.key) {
        case "ArrowUp": newDx = 0; newDy = -1; break;
        case "ArrowDown": newDx = 0; newDy = 1; break;
        case "ArrowLeft": newDx = -1; newDy = 0; break;
        case "ArrowRight": newDx = 1; newDy = 0; break;
        default: return;
    }
    if(reversedControls) {
        newDx = -newDx;
        newDy = -newDy;
    }
    changeDirection(newDx, newDy);
});

// è§¦æ‘¸æ§åˆ¶
let touchStartX = 0, touchStartY = 0;
const minSwipeDistance = 15;

canvas.addEventListener("touchstart", e => {
    e.preventDefault();
    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
}, { passive: false });

canvas.addEventListener("touchmove", e => {
    e.preventDefault();
});

canvas.addEventListener("touchend", e => {
    const touch = e.changedTouches[0];
    let distX = touch.clientX - touchStartX;
    let distY = touch.clientY - touchStartY;

    if (Math.abs(distX) < minSwipeDistance && Math.abs(distY) < minSwipeDistance) return;

    let newDx = 0, newDy = 0;
    if (Math.abs(distX) > Math.abs(distY)) {
        newDx = distX > 0 ? 1 : -1;
    } else {
        newDy = distY > 0 ? 1 : -1;
    }

    if(reversedControls) {
        newDx = -newDx;
        newDy = -newDy;
    }
    changeDirection(newDx, newDy);
});

</script>
</body>
</html>
